{"ast":null,"code":"class DocumentVerificationService {\n  constructor() {\n    this.STORAGE_KEY = 'document_verification_data';\n  }\n  /**\n   * Отправляет документы на верификацию\n   */\n  async submitVerification(userId, formData) {\n    try {\n      // В реальном приложении здесь будет API запрос\n      // Сейчас сохраняем в localStorage для демонстрации\n\n      const verificationData = {\n        id: `verification_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        userId,\n        status: 'pending',\n        submittedAt: new Date().toISOString(),\n        documents: {\n          passportFront: await this.fileToBase64(formData.passportFront),\n          passportBack: await this.fileToBase64(formData.passportBack),\n          selfieWithPassport: await this.fileToBase64(formData.selfieWithPassport)\n        }\n      };\n\n      // Сохраняем в localStorage\n      this.saveVerificationToStorage(verificationData);\n\n      // Имитируем задержку API\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      return {\n        success: true,\n        verificationId: verificationData.id,\n        message: 'Документы успешно отправлены на верификацию'\n      };\n    } catch (error) {\n      console.error('Ошибка при отправке верификации:', error);\n      return {\n        success: false,\n        message: 'Произошла ошибка при отправке документов. Попробуйте еще раз.',\n        errors: ['Ошибка сервера']\n      };\n    }\n  }\n\n  /**\n   * Получает статус верификации пользователя\n   */\n  async getVerificationStatus(userId) {\n    try {\n      const stored = localStorage.getItem(this.STORAGE_KEY);\n      if (stored) {\n        const verifications = JSON.parse(stored);\n        return verifications.find(v => v.userId === userId) || null;\n      }\n      return null;\n    } catch (error) {\n      console.error('Ошибка при получении статуса верификации:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Получает все верификации (для администраторов)\n   */\n  async getAllVerifications() {\n    try {\n      const stored = localStorage.getItem(this.STORAGE_KEY);\n      if (stored) {\n        return JSON.parse(stored);\n      }\n      return [];\n    } catch (error) {\n      console.error('Ошибка при получении всех верификаций:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Обновляет статус верификации (для администраторов)\n   */\n  async updateVerificationStatus(verificationId, status, notes) {\n    try {\n      const stored = localStorage.getItem(this.STORAGE_KEY);\n      if (stored) {\n        const verifications = JSON.parse(stored);\n        const verificationIndex = verifications.findIndex(v => v.id === verificationId);\n        if (verificationIndex !== -1) {\n          verifications[verificationIndex].status = status;\n          verifications[verificationIndex].reviewedAt = new Date().toISOString();\n          if (notes) {\n            verifications[verificationIndex].notes = notes;\n          }\n          localStorage.setItem(this.STORAGE_KEY, JSON.stringify(verifications));\n          return {\n            success: true,\n            message: `Статус верификации обновлен на: ${status === 'approved' ? 'одобрено' : 'отклонено'}`\n          };\n        }\n      }\n      return {\n        success: false,\n        message: 'Верификация не найдена'\n      };\n    } catch (error) {\n      console.error('Ошибка при обновлении статуса верификации:', error);\n      return {\n        success: false,\n        message: 'Произошла ошибка при обновлении статуса'\n      };\n    }\n  }\n\n  /**\n   * Конвертирует файл в base64 для хранения в localStorage\n   */\n  async fileToBase64(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.readAsDataURL(file);\n      reader.onload = () => resolve(reader.result);\n      reader.onerror = error => reject(error);\n    });\n  }\n\n  /**\n   * Сохраняет данные верификации в localStorage\n   */\n  saveVerificationToStorage(verificationData) {\n    try {\n      const stored = localStorage.getItem(this.STORAGE_KEY);\n      let verifications = [];\n      if (stored) {\n        verifications = JSON.parse(stored);\n        // Удаляем старую верификацию пользователя, если есть\n        verifications = verifications.filter(v => v.userId !== verificationData.userId);\n      }\n      verifications.push(verificationData);\n      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(verifications));\n    } catch (error) {\n      console.error('Ошибка при сохранении верификации в localStorage:', error);\n    }\n  }\n\n  /**\n   * Очищает все данные верификации (для тестирования)\n   */\n  clearAllVerifications() {\n    try {\n      localStorage.removeItem(this.STORAGE_KEY);\n      console.log('Все данные верификации очищены');\n    } catch (error) {\n      console.error('Ошибка при очистке данных верификации:', error);\n    }\n  }\n}\nexport const documentVerificationService = new DocumentVerificationService();\nexport default documentVerificationService;","map":{"version":3,"names":["DocumentVerificationService","constructor","STORAGE_KEY","submitVerification","userId","formData","verificationData","id","Date","now","Math","random","toString","substr","status","submittedAt","toISOString","documents","passportFront","fileToBase64","passportBack","selfieWithPassport","saveVerificationToStorage","Promise","resolve","setTimeout","success","verificationId","message","error","console","errors","getVerificationStatus","stored","localStorage","getItem","verifications","JSON","parse","find","v","getAllVerifications","updateVerificationStatus","notes","verificationIndex","findIndex","reviewedAt","setItem","stringify","file","reject","reader","FileReader","readAsDataURL","onload","result","onerror","filter","push","clearAllVerifications","removeItem","log","documentVerificationService"],"sources":["/Users/avtnmv/Documents/Front-End/logistics-project-react — копия/src/services/documentVerificationService.ts"],"sourcesContent":["import { VerificationFormData } from '../components/VerificationForm';\n\nexport interface VerificationStatus {\n  id: string;\n  userId: string;\n  status: 'pending' | 'approved' | 'rejected';\n  submittedAt: string;\n  reviewedAt?: string;\n  documents: {\n    passportFront: string;\n    passportBack: string;\n    selfieWithPassport: string;\n  };\n  notes?: string;\n}\n\nexport interface VerificationResponse {\n  success: boolean;\n  verificationId?: string;\n  message: string;\n  errors?: string[];\n}\n\nclass DocumentVerificationService {\n  private readonly STORAGE_KEY = 'document_verification_data';\n\n  /**\n   * Отправляет документы на верификацию\n   */\n  async submitVerification(userId: string, formData: VerificationFormData): Promise<VerificationResponse> {\n    try {\n      // В реальном приложении здесь будет API запрос\n      // Сейчас сохраняем в localStorage для демонстрации\n      \n      const verificationData: VerificationStatus = {\n        id: `verification_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        userId,\n        status: 'pending',\n        submittedAt: new Date().toISOString(),\n        documents: {\n          passportFront: await this.fileToBase64(formData.passportFront!),\n          passportBack: await this.fileToBase64(formData.passportBack!),\n          selfieWithPassport: await this.fileToBase64(formData.selfieWithPassport!)\n        }\n      };\n\n      // Сохраняем в localStorage\n      this.saveVerificationToStorage(verificationData);\n\n      // Имитируем задержку API\n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      return {\n        success: true,\n        verificationId: verificationData.id,\n        message: 'Документы успешно отправлены на верификацию'\n      };\n\n    } catch (error) {\n      console.error('Ошибка при отправке верификации:', error);\n      return {\n        success: false,\n        message: 'Произошла ошибка при отправке документов. Попробуйте еще раз.',\n        errors: ['Ошибка сервера']\n      };\n    }\n  }\n\n  /**\n   * Получает статус верификации пользователя\n   */\n  async getVerificationStatus(userId: string): Promise<VerificationStatus | null> {\n    try {\n      const stored = localStorage.getItem(this.STORAGE_KEY);\n      if (stored) {\n        const verifications: VerificationStatus[] = JSON.parse(stored);\n        return verifications.find(v => v.userId === userId) || null;\n      }\n      return null;\n    } catch (error) {\n      console.error('Ошибка при получении статуса верификации:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Получает все верификации (для администраторов)\n   */\n  async getAllVerifications(): Promise<VerificationStatus[]> {\n    try {\n      const stored = localStorage.getItem(this.STORAGE_KEY);\n      if (stored) {\n        return JSON.parse(stored);\n      }\n      return [];\n    } catch (error) {\n      console.error('Ошибка при получении всех верификаций:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Обновляет статус верификации (для администраторов)\n   */\n  async updateVerificationStatus(\n    verificationId: string, \n    status: 'approved' | 'rejected', \n    notes?: string\n  ): Promise<VerificationResponse> {\n    try {\n      const stored = localStorage.getItem(this.STORAGE_KEY);\n      if (stored) {\n        const verifications: VerificationStatus[] = JSON.parse(stored);\n        const verificationIndex = verifications.findIndex(v => v.id === verificationId);\n        \n        if (verificationIndex !== -1) {\n          verifications[verificationIndex].status = status;\n          verifications[verificationIndex].reviewedAt = new Date().toISOString();\n          if (notes) {\n            verifications[verificationIndex].notes = notes;\n          }\n          \n          localStorage.setItem(this.STORAGE_KEY, JSON.stringify(verifications));\n          \n          return {\n            success: true,\n            message: `Статус верификации обновлен на: ${status === 'approved' ? 'одобрено' : 'отклонено'}`\n          };\n        }\n      }\n      \n      return {\n        success: false,\n        message: 'Верификация не найдена'\n      };\n    } catch (error) {\n      console.error('Ошибка при обновлении статуса верификации:', error);\n      return {\n        success: false,\n        message: 'Произошла ошибка при обновлении статуса'\n      };\n    }\n  }\n\n  /**\n   * Конвертирует файл в base64 для хранения в localStorage\n   */\n  private async fileToBase64(file: File): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.readAsDataURL(file);\n      reader.onload = () => resolve(reader.result as string);\n      reader.onerror = error => reject(error);\n    });\n  }\n\n  /**\n   * Сохраняет данные верификации в localStorage\n   */\n  private saveVerificationToStorage(verificationData: VerificationStatus): void {\n    try {\n      const stored = localStorage.getItem(this.STORAGE_KEY);\n      let verifications: VerificationStatus[] = [];\n      \n      if (stored) {\n        verifications = JSON.parse(stored);\n        // Удаляем старую верификацию пользователя, если есть\n        verifications = verifications.filter(v => v.userId !== verificationData.userId);\n      }\n      \n      verifications.push(verificationData);\n      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(verifications));\n      \n    } catch (error) {\n      console.error('Ошибка при сохранении верификации в localStorage:', error);\n    }\n  }\n\n  /**\n   * Очищает все данные верификации (для тестирования)\n   */\n  clearAllVerifications(): void {\n    try {\n      localStorage.removeItem(this.STORAGE_KEY);\n      console.log('Все данные верификации очищены');\n    } catch (error) {\n      console.error('Ошибка при очистке данных верификации:', error);\n    }\n  }\n}\n\nexport const documentVerificationService = new DocumentVerificationService();\nexport default documentVerificationService;\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}