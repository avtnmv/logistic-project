{"ast":null,"code":"class DocumentVerificationService {\n  constructor() {\n    this.STORAGE_KEY_PREFIX = 'document_verification_';\n  }\n  /**\n   * Отправляет документы на верификацию\n   */\n  async submitVerification(userId, formData) {\n    try {\n      // В реальном приложении здесь будет API запрос\n      // Сейчас сохраняем в localStorage для демонстрации\n\n      const verificationData = {\n        id: `verification_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        userId,\n        status: 'pending',\n        submittedAt: new Date().toISOString(),\n        documents: {\n          passportFront: await this.fileToBase64(formData.passportFront),\n          passportBack: await this.fileToBase64(formData.passportBack),\n          selfieWithPassport: await this.fileToBase64(formData.selfieWithPassport)\n        }\n      };\n\n      // Сохраняем в localStorage\n      this.saveVerificationToStorage(verificationData);\n\n      // Имитируем задержку API\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      return {\n        success: true,\n        verificationId: verificationData.id,\n        message: 'Документы успешно отправлены на верификацию'\n      };\n    } catch (error) {\n      console.error('Ошибка при отправке верификации:', error);\n      return {\n        success: false,\n        message: 'Произошла ошибка при отправке документов. Попробуйте еще раз.',\n        errors: ['Ошибка сервера']\n      };\n    }\n  }\n\n  /**\n   * Получает статус верификации пользователя\n   */\n  async getVerificationStatus(userId) {\n    try {\n      const storageKey = `${this.STORAGE_KEY_PREFIX}${userId}`;\n      const stored = localStorage.getItem(storageKey);\n      if (stored) {\n        const verification = JSON.parse(stored);\n        return verification;\n      }\n      return null;\n    } catch (error) {\n      console.error('Ошибка при получении статуса верификации:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Получает все верификации (для администраторов)\n   */\n  async getAllVerifications() {\n    try {\n      const allStorageKey = 'document_verification_data';\n      const stored = localStorage.getItem(allStorageKey);\n      if (stored) {\n        return JSON.parse(stored);\n      }\n      return [];\n    } catch (error) {\n      console.error('Ошибка при получении всех верификаций:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Обновляет статус верификации (для администраторов)\n   */\n  async updateVerificationStatus(verificationId, status, notes) {\n    try {\n      // Сначала ищем верификацию в общем списке\n      const allStorageKey = 'document_verification_data';\n      const stored = localStorage.getItem(allStorageKey);\n      if (stored) {\n        const verifications = JSON.parse(stored);\n        const verificationIndex = verifications.findIndex(v => v.id === verificationId);\n        if (verificationIndex !== -1) {\n          const verification = verifications[verificationIndex];\n\n          // Обновляем в общем списке\n          verifications[verificationIndex].status = status;\n          verifications[verificationIndex].reviewedAt = new Date().toISOString();\n          if (notes) {\n            verifications[verificationIndex].notes = notes;\n          }\n          localStorage.setItem(allStorageKey, JSON.stringify(verifications));\n\n          // Также обновляем в пользовательском хранилище\n          const userStorageKey = `${this.STORAGE_KEY_PREFIX}${verification.userId}`;\n          localStorage.setItem(userStorageKey, JSON.stringify(verifications[verificationIndex]));\n          return {\n            success: true,\n            message: `Статус верификации обновлен на: ${status === 'approved' ? 'одобрено' : 'отклонено'}`\n          };\n        }\n      }\n      return {\n        success: false,\n        message: 'Верификация не найдена'\n      };\n    } catch (error) {\n      console.error('Ошибка при обновлении статуса верификации:', error);\n      return {\n        success: false,\n        message: 'Произошла ошибка при обновлении статуса'\n      };\n    }\n  }\n\n  /**\n   * Конвертирует файл в base64 для хранения в localStorage\n   */\n  async fileToBase64(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.readAsDataURL(file);\n      reader.onload = () => resolve(reader.result);\n      reader.onerror = error => reject(error);\n    });\n  }\n\n  /**\n   * Сохраняет данные верификации в localStorage\n   */\n  saveVerificationToStorage(verificationData) {\n    try {\n      const storageKey = `${this.STORAGE_KEY_PREFIX}${verificationData.userId}`;\n\n      // Сохраняем верификацию для конкретного пользователя\n      localStorage.setItem(storageKey, JSON.stringify(verificationData));\n\n      // Также сохраняем в общий список для администраторов (обратная совместимость)\n      const allStorageKey = 'document_verification_data';\n      const stored = localStorage.getItem(allStorageKey);\n      let verifications = [];\n      if (stored) {\n        verifications = JSON.parse(stored);\n        // Удаляем старую верификацию пользователя, если есть\n        verifications = verifications.filter(v => v.userId !== verificationData.userId);\n      }\n      verifications.push(verificationData);\n      localStorage.setItem(allStorageKey, JSON.stringify(verifications));\n    } catch (error) {\n      console.error('Ошибка при сохранении верификации в localStorage:', error);\n    }\n  }\n\n  /**\n   * Очищает все данные верификации (для тестирования)\n   */\n  clearAllVerifications() {\n    try {\n      // Очищаем общий список\n      localStorage.removeItem('document_verification_data');\n\n      // Очищаем все пользовательские верификации\n      const keys = Object.keys(localStorage);\n      keys.forEach(key => {\n        if (key.startsWith(this.STORAGE_KEY_PREFIX)) {\n          localStorage.removeItem(key);\n        }\n      });\n      console.log('Все данные верификации очищены');\n    } catch (error) {\n      console.error('Ошибка при очистке данных верификации:', error);\n    }\n  }\n}\nexport const documentVerificationService = new DocumentVerificationService();\nexport default documentVerificationService;","map":{"version":3,"names":["DocumentVerificationService","constructor","STORAGE_KEY_PREFIX","submitVerification","userId","formData","verificationData","id","Date","now","Math","random","toString","substr","status","submittedAt","toISOString","documents","passportFront","fileToBase64","passportBack","selfieWithPassport","saveVerificationToStorage","Promise","resolve","setTimeout","success","verificationId","message","error","console","errors","getVerificationStatus","storageKey","stored","localStorage","getItem","verification","JSON","parse","getAllVerifications","allStorageKey","updateVerificationStatus","notes","verifications","verificationIndex","findIndex","v","reviewedAt","setItem","stringify","userStorageKey","file","reject","reader","FileReader","readAsDataURL","onload","result","onerror","filter","push","clearAllVerifications","removeItem","keys","Object","forEach","key","startsWith","log","documentVerificationService"],"sources":["/Users/avtnmv/Documents/Front-End/logistics-project-react/src/services/documentVerificationService.ts"],"sourcesContent":["import { VerificationFormData } from '../components/VerificationForm';\n\nexport interface VerificationStatus {\n  id: string;\n  userId: string;\n  status: 'pending' | 'approved' | 'rejected';\n  submittedAt: string;\n  reviewedAt?: string;\n  documents: {\n    passportFront: string;\n    passportBack: string;\n    selfieWithPassport: string;\n  };\n  notes?: string;\n}\n\nexport interface VerificationResponse {\n  success: boolean;\n  verificationId?: string;\n  message: string;\n  errors?: string[];\n}\n\nclass DocumentVerificationService {\n  private readonly STORAGE_KEY_PREFIX = 'document_verification_';\n\n  /**\n   * Отправляет документы на верификацию\n   */\n  async submitVerification(userId: string, formData: VerificationFormData): Promise<VerificationResponse> {\n    try {\n      // В реальном приложении здесь будет API запрос\n      // Сейчас сохраняем в localStorage для демонстрации\n      \n      const verificationData: VerificationStatus = {\n        id: `verification_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        userId,\n        status: 'pending',\n        submittedAt: new Date().toISOString(),\n        documents: {\n          passportFront: await this.fileToBase64(formData.passportFront!),\n          passportBack: await this.fileToBase64(formData.passportBack!),\n          selfieWithPassport: await this.fileToBase64(formData.selfieWithPassport!)\n        }\n      };\n\n      // Сохраняем в localStorage\n      this.saveVerificationToStorage(verificationData);\n\n      // Имитируем задержку API\n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      return {\n        success: true,\n        verificationId: verificationData.id,\n        message: 'Документы успешно отправлены на верификацию'\n      };\n\n    } catch (error) {\n      console.error('Ошибка при отправке верификации:', error);\n      return {\n        success: false,\n        message: 'Произошла ошибка при отправке документов. Попробуйте еще раз.',\n        errors: ['Ошибка сервера']\n      };\n    }\n  }\n\n  /**\n   * Получает статус верификации пользователя\n   */\n  async getVerificationStatus(userId: string): Promise<VerificationStatus | null> {\n    try {\n      const storageKey = `${this.STORAGE_KEY_PREFIX}${userId}`;\n      \n      const stored = localStorage.getItem(storageKey);\n      if (stored) {\n        const verification: VerificationStatus = JSON.parse(stored);\n        return verification;\n      }\n      return null;\n    } catch (error) {\n      console.error('Ошибка при получении статуса верификации:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Получает все верификации (для администраторов)\n   */\n  async getAllVerifications(): Promise<VerificationStatus[]> {\n    try {\n      const allStorageKey = 'document_verification_data';\n      const stored = localStorage.getItem(allStorageKey);\n      if (stored) {\n        return JSON.parse(stored);\n      }\n      return [];\n    } catch (error) {\n      console.error('Ошибка при получении всех верификаций:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Обновляет статус верификации (для администраторов)\n   */\n  async updateVerificationStatus(\n    verificationId: string, \n    status: 'approved' | 'rejected', \n    notes?: string\n  ): Promise<VerificationResponse> {\n    try {\n      // Сначала ищем верификацию в общем списке\n      const allStorageKey = 'document_verification_data';\n      const stored = localStorage.getItem(allStorageKey);\n      if (stored) {\n        const verifications: VerificationStatus[] = JSON.parse(stored);\n        const verificationIndex = verifications.findIndex(v => v.id === verificationId);\n        \n        if (verificationIndex !== -1) {\n          const verification = verifications[verificationIndex];\n          \n          // Обновляем в общем списке\n          verifications[verificationIndex].status = status;\n          verifications[verificationIndex].reviewedAt = new Date().toISOString();\n          if (notes) {\n            verifications[verificationIndex].notes = notes;\n          }\n          \n          localStorage.setItem(allStorageKey, JSON.stringify(verifications));\n          \n          // Также обновляем в пользовательском хранилище\n          const userStorageKey = `${this.STORAGE_KEY_PREFIX}${verification.userId}`;\n          localStorage.setItem(userStorageKey, JSON.stringify(verifications[verificationIndex]));\n          \n          return {\n            success: true,\n            message: `Статус верификации обновлен на: ${status === 'approved' ? 'одобрено' : 'отклонено'}`\n          };\n        }\n      }\n      \n      return {\n        success: false,\n        message: 'Верификация не найдена'\n      };\n    } catch (error) {\n      console.error('Ошибка при обновлении статуса верификации:', error);\n      return {\n        success: false,\n        message: 'Произошла ошибка при обновлении статуса'\n      };\n    }\n  }\n\n  /**\n   * Конвертирует файл в base64 для хранения в localStorage\n   */\n  private async fileToBase64(file: File): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.readAsDataURL(file);\n      reader.onload = () => resolve(reader.result as string);\n      reader.onerror = error => reject(error);\n    });\n  }\n\n  /**\n   * Сохраняет данные верификации в localStorage\n   */\n  private saveVerificationToStorage(verificationData: VerificationStatus): void {\n    try {\n      const storageKey = `${this.STORAGE_KEY_PREFIX}${verificationData.userId}`;\n      \n      // Сохраняем верификацию для конкретного пользователя\n      localStorage.setItem(storageKey, JSON.stringify(verificationData));\n      \n      // Также сохраняем в общий список для администраторов (обратная совместимость)\n      const allStorageKey = 'document_verification_data';\n      const stored = localStorage.getItem(allStorageKey);\n      let verifications: VerificationStatus[] = [];\n      \n      if (stored) {\n        verifications = JSON.parse(stored);\n        // Удаляем старую верификацию пользователя, если есть\n        verifications = verifications.filter(v => v.userId !== verificationData.userId);\n      }\n      \n      verifications.push(verificationData);\n      localStorage.setItem(allStorageKey, JSON.stringify(verifications));\n      \n    } catch (error) {\n      console.error('Ошибка при сохранении верификации в localStorage:', error);\n    }\n  }\n\n  /**\n   * Очищает все данные верификации (для тестирования)\n   */\n  clearAllVerifications(): void {\n    try {\n      // Очищаем общий список\n      localStorage.removeItem('document_verification_data');\n      \n      // Очищаем все пользовательские верификации\n      const keys = Object.keys(localStorage);\n      keys.forEach(key => {\n        if (key.startsWith(this.STORAGE_KEY_PREFIX)) {\n          localStorage.removeItem(key);\n        }\n      });\n      \n      console.log('Все данные верификации очищены');\n    } catch (error) {\n      console.error('Ошибка при очистке данных верификации:', error);\n    }\n  }\n}\n\nexport const documentVerificationService = new DocumentVerificationService();\nexport default documentVerificationService;\n\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}